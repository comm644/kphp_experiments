<?php
#ifndef KPHP
//PHP only. not for KPHP


namespace Sigmalab\SimpleReflection;

use ReflectionClass;
use ReflectionMethod;

class ReflectionGenerator
{


	/**
	 * @param object $object
	 * @param $propertyName
	 * @param $m
	 * @return array
	 * @throws \ReflectionException
	 */
	function getArrayItemClassName(object $object, string $propertyName): array
	{
		$ref = new \ReflectionClass(get_class($object));
		$prop = $ref->getProperty($propertyName);
		preg_match("/@var\s+([A-Za-z_]+)(\[\])?/", $prop->getDocComment(), $m);
		$itemClassName = $m[1];
		if (count($m) == 3) {
			return array($itemClassName, true);
		}
		return array($itemClassName, false);
	}

	function getMixedType(object $object, string $propertyName)
	{
		list($decl, $isArray) = $this->getArrayItemClassName($object, $propertyName);

		return $this->getMixedTypeByDecl($isArray, $decl);
	}


	function generate(string $classNameFullName)
	{
		$object = new $classNameFullName;
		$className = get_class($object);

		$className =  basename(str_replace("\\", "/", $classNameFullName));
		$namespace = dirname(str_replace("\\", "/", $classNameFullName));
		if ($namespace) {
			$namespace = "namespace ".str_replace("/", "\\", $namespace) .";\n\n";
		}

		ob_start();

		echo <<<TEXT
<?php
{$namespace}
use \Sigmalab\SimpleReflection\IReflectedObject;

//autogenerated
class {$className}_reflection implements \Sigmalab\SimpleReflection\ICanReflection
{
	/** ${className} */
	private ${className} \$instance;
	
	public function __construct(${className} \$instance) 
	{
		\$this->instance = \$instance;
	}
TEXT;

		echo <<<TEXT
	
	/**
	 * @kphp-required
	 * @param string \$name
	 * @return \Sigmalab\SimpleReflection\TypeName
	 */
	public function getPropertyType(string \$name) : \Sigmalab\SimpleReflection\TypeName
	{
		//autogenerated map
		switch (\$name) {

TEXT;

		$declareType = [];
		$declareInit = [];
		foreach (get_object_vars($object) as $key => $value) {

			list($decl, $isArray) = $this->getArrayItemClassName($object, $key);

			if ($isArray) {
				switch ($decl) {
					case 'int':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intArray';
						break;
					case 'integer':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intArray';
						break;
					case 'string':
						$code = '\Sigmalab\SimpleReflection\TypeName::$stringArray';
						break;
					case 'bool':
						$code = '\Sigmalab\SimpleReflection\TypeName::$boolArray';
						break;
					case 'float':
						$code = '\Sigmalab\SimpleReflection\TypeName::$floatArray';
						break;
					case 'mixed':
						$code = '\Sigmalab\SimpleReflection\TypeName::$mixedArray';
						break;
					default:
						$declareType[] = "private static \Sigmalab\SimpleReflection\TypeName \${$key}_type;";
						$declareInit[] = "self::\${$key}_type = new \Sigmalab\SimpleReflection\TypeName('$decl', \Sigmalab\SimpleReflection\TypeName::Array );";
						$code = "self::\${$key}_type";
						break;
				}
			} else {
				switch ($decl) {
					case 'int':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intValue';
						break;
					case 'integer':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intValue';
						break;
					case 'string':
						$code = '\Sigmalab\SimpleReflection\TypeName::$stringValue';
						break;
					case 'bool':
						$code = '\Sigmalab\SimpleReflection\TypeName::$boolValue';
						break;
					case 'float':
						$code = '\Sigmalab\SimpleReflection\TypeName::$floatValue';
						break;
					case 'mixed':
						$code = '\Sigmalab\SimpleReflection\TypeName::$mixedValue';
						break;
					default:
						$declareType[] = "private static \Sigmalab\SimpleReflection\TypeName \${$key}_type;";
						$declareInit[] = "self::\${$key}_type = new \Sigmalab\SimpleReflection\TypeName('$decl', \Sigmalab\SimpleReflection\TypeName::Object );";
						$code = "self::\${$key}_type";
						break;
				}
			}
			echo <<<TEXT
			case '$key': return $code;

TEXT;
		}
		echo <<<TEXT
		}             
		return \Sigmalab\SimpleReflection\TypeName::\$intValue;
	}
	

	/**
	 * @kphp-required
	 * @param string \$name
	 * @param \Sigmalab\SimpleReflection\ValueMixed \$value
	 */
	public function setPropertyValue(string \$name, \Sigmalab\SimpleReflection\ValueMixed \$value) : void
	{
		//autogenerated map
		switch (\$name) {

TEXT;

		$ref = new ReflectionClass($object);

		foreach (get_object_vars($object) as $key => $value) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $key);

			$prop = $ref->getProperty($key);
			//$isNullable = $prop->getType()->allowsNull();

			echo "/* $decl */\n";
			$type = gettype($value);
			if ($type === "integer") $type = "int";

			echo <<<TEXT
		case '$key':

TEXT;

			$getter = self::getGetter($isArray, $decl);
			if ($isArray) {
				switch ($decl) {
					case 'int':
					case 'integer':
					case 'string':
					case 'bool':
					case 'float':
					case 'mixed':
						echo <<<TEXT
				if (\$value instanceof \Sigmalab\SimpleReflection\ValueScalars) {
					\$this->instance->$key  = \$value->$getter();
				}

TEXT;
						break;
					default:
						echo <<<TEXT
				\$this->instance->$key = [];
				if (\$value instanceof \Sigmalab\SimpleReflection\ValueObjects) {
					foreach (\$value->getValue() as \$arrayValue) {
						\$this->instance->{$key}[] =  instance_cast(\$arrayValue, $decl::class);
					}
				}

TEXT;
						break;
				}
			} else {
				switch ($decl) {
					case 'int':
					case 'integer':
					case 'string':
					case 'bool':
					case 'float':
					case 'mixed':
						echo <<<TEXT
			if (\$value instanceof \Sigmalab\SimpleReflection\ValueScalar) {
				\$this->instance->$key = \$value->$getter();
			}


TEXT;
						break;

					default:
						echo <<<TEXT
			if ( \$value instanceof \Sigmalab\SimpleReflection\ValueObject ) {
				\$this->instance->$key = instance_cast(\$value->getValue(), $decl::class); 
			}

TEXT;
						break;
				}
			}
			echo <<<TEXT
			break;

TEXT;
		}
		echo <<<TEXT
		}
	}

	/**
	 * @kphp-required
	 * @param string \$name
	 * @return \Sigmalab\SimpleReflection\ValueMixed
	 */
	public function getPropertyValue(string \$name) :\Sigmalab\SimpleReflection\ValueMixed
	{
		//autogenerated map
		switch (\$name) {

TEXT;

		foreach (get_object_vars($object) as $key => $value) {
			$mixedType = $this->getMixedType($object, $key);
			echo <<<TEXT
			case '$key': return new $mixedType( \$this->instance->$key );

TEXT;
		}

		echo <<<TEXT
		}
		return null;
	}
	
TEXT;

		$declaredTypes = implode("\n	", $declareType);
		$declaredInit = implode("\n		", $declareInit);
		echo <<<TEXT

	public static function registerClass()
	{   
		\Sigmalab\SimpleReflection\ClassRegistry::registerClass('{$className}', function(){ return new $className; });
		\Sigmalab\SimpleReflection\ClassRegistry::registerReflection('{$className}_reflection', function(object \$instance){ 
			return new {$className}_reflection(instance_cast(\$instance, ${className}::class)); 
		});
		{$declaredInit}
	}
	{$declaredTypes}

TEXT;

		$ref = new ReflectionClass($object);
		$methods = $ref->getMethods(ReflectionMethod::IS_PUBLIC);

		echo <<<TEXT

	/**
	* @return mixed
	*/
	public function invoke_as_mixed(string \$methodName, array \$args) 
	{
		return 0;
	}
	public function invoke_as_object(string \$methodName, array \$args) :?IReflectedObject
	{
		return null;
	}

	/**
	 * @param string \$methodName
	 * @param \Sigmalab\SimpleReflection\ValueMixed[] \$args
	 * @throws \Exception
	 */
	public function invoke_as_void(string \$methodName, array \$args) :void
	{
		switch (\$methodName)
		{

TEXT;


		foreach ($methods as $method) {
			if ($method->name == "__construct") continue;


			echo <<<TEXT
			case '{$method->name}':
				\$this->invoke_{$method->name}(\$args);
				break;

TEXT;

		}

		echo <<<TEXT
		}
	}

TEXT;

		foreach ($methods as $method) {
			if ($method->name == "__construct") continue;
			echo <<<TEXT
\n	/**
	 * @param \Sigmalab\SimpleReflection\ValueMixed[] \$args
	 * @throws \Exception
	 */
	private function invoke_{$method->name}(array \$args)
	{\n
TEXT;
			$paramTypes = [];
			preg_match_all('/@param\s+([A-Za-z_\\\]+)(\|null)?\s*(\[\])?\s+\$([A-Za-z0-9_]+)/', $method->getDocComment(), $m);

			foreach ($m[4] as $idx => $paramName) {
				$paramTypes[$paramName] = (object)[
					"name" => $paramName,
					"type" => $m[1][$idx],
					"isArray" => $m[3][$idx] == "[]",
					"isNullable"=> $m[2][$idx] == "|null"
				];
			}

			$args = [];
			foreach ($method->getParameters() as $idx => $param) {

				$type = $param->getType();
				//$castType = $type->isBuiltin() ? $type : "object";

				$args[] = "\$arg{$idx}";
				$valueType = $this->getMixedTypeByDecl($param->isArray(), $paramTypes[$param->name]->type);
				$getter = $this->getGetter($param->isArray(), $paramTypes[$param->name]->type);

				if (!isset($paramTypes[$param->name])) {
					die( "Error: param  {$param->name} not defined in phpdoc in {$method->name}\n{$method->getDocComment()}\n" );
				}
				$objectType = $paramTypes[$param->name]->type;
				if ($type && $type->isBuiltin() ) {
					echo <<<TEXT
\n		/** @var $type \$arg{$idx} */      
		\$value{$idx} = \$args[{$idx}];
		if ( \$value{$idx} instanceof $valueType) \$arg{$idx} = \$value{$idx}->$getter();
		else throw new \Exception("Invalid argument {$idx}");\n\n
TEXT;
					continue;
				}
				if ($objectType == "mixed" ) {
					echo <<<TEXT
\n		/** @var $type \$arg{$idx} */      
		\$value{$idx} = \$args[{$idx}];
		if ( \$value{$idx} instanceof $valueType) \$arg{$idx} = \$value{$idx}->$getter();
		else throw new \Exception("Invalid argument {$idx}");\n\n
TEXT;
					continue;
				}


				echo <<<TEXT
\n		/** @var $objectType \$arg{$idx} */      
		\$value{$idx} = \$args[{$idx}];
		if ( \$value{$idx} instanceof $valueType) \$arg{$idx} = instance_cast(\$value{$idx}, $objectType::class);
		else throw new \Exception("Invalid argument {$idx}");\n\n
TEXT;
			}
			$arglist = implode(",", $args);
			echo <<<TEXT
		\$this->instance->{$method->name}($arglist);\n
TEXT;
			$this->closeFunction();
		}

		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param string \$value
	 * @throws \Exception
	 */
	public function set_as_string(string  \$name, string \$value):void
	{

TEXT;
		$this->generateDirectSetSwitch($object, 'string');
		$this->closeFunction();

		echo <<<TEXT
	/**
	 * @param string \$name
	 * @return string
	 * @throws \Exception
	 */
	public function get_as_string(string  \$name):string
	{

TEXT;
		$this->generateDirectGetSwitch($object, 'string');
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param int \$value
	 * @throws \Exception
	 */
	public function set_as_int(string  \$name, int \$value):void
	{

TEXT;
		$this->generateDirectSetSwitch($object, 'integer');
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @return int
	 * @throws \Exception
	 */
	public function get_as_int(string  \$name):int
	{

TEXT;
		ob_start();
		$count = $this->generateDirectGetSwitch($object, 'integer');
		if (!$count) {
			ob_clean();
			echo <<<TEXT
		return 0;\n
TEXT;
		} else {
			echo ob_get_clean();
		}

		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param float \$value
	 * @throws \Exception
	 */
	public function set_as_float(string  \$name, float \$value):void
	{

TEXT;
		$this->generateDirectSetSwitch($object, 'double');
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @return float
	 * @throws \Exception
	 */
	public function get_as_float(string  \$name):float
	{

TEXT;
		$this->generateDirectGetSwitch($object, 'double');
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param bool \$value
	 * @throws \Exception
	 */
	public function set_as_bool(string  \$name, bool \$value):void
	{

TEXT;
		$this->generateDirectSetSwitch($object, 'boolean');
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @return bool
	 * @throws \Exception
	 */
	public function get_as_bool(string  \$name):bool
	{

TEXT;
		$this->generateDirectGetSwitch($object, 'bool');
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @throws \Exception
	 */
	public function set_as_null(string  \$name):void
	{

TEXT;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			$type = gettype($prop->getValue($object));
			$key = $prop->name;
			if ($prop->getType() && !$prop->getType()->allowsNull()) continue;
			echo <<<TEXT
			case '$key': \$this->instance->$key  = null; break;

TEXT;
		}
		$this->closeSwitch();
		$this->closeFunction();

		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param mixed \$value
	 * @throws \Exception
	 */
	public function set_as_mixed(string \$name, \$value):void
	{

TEXT;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $prop->name);
			$key = $prop->name;
			if ($prop->getType() && !$prop->getType()->isBuiltin()) continue;
			$cast = "($decl)";
			if  ($decl == "mixed") {
				$cast = "";
			}
			if ($isArray) {
				if ($this->isScalarType($decl)) {
					echo <<<TEXT
			case '$key': \$this->instance->$key  = [];
				if (!count( \$value) ) break;
				\$arrayKey  = array_first_key(\$value);
				if ( \$arrayKey === 0) {
					foreach( \$value as \$item ) {
						\$this->instance->{$key}[] = $cast\$item;
					}
				}
				else {
					foreach( \$value as \$arrayKey=>\$item ) {
						\$this->instance->{$key}[\$arrayKey] = $cast\$item;
					}
				}
				break;

TEXT;
				}
				continue;
			}


			echo <<<TEXT
			case '$key': \$this->instance->$key  = $cast\$value; break;

TEXT;
		}
		$this->closeSwitch();
		$this->closeFunction();

		echo <<<TEXT
	/**
	 * @param string \$name
	 * @return mixed
	 * @throws \Exception
	 */
	public function get_as_mixed(string \$name)
	{

TEXT;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $prop->name);
			$key = $prop->name;
			if ($prop->getType() && !$prop->getType()->isBuiltin()) continue;
			if ($isArray) {
				if ($this->isScalarType($decl)) {
					echo <<<TEXT
			case '$key': return \$this->instance->$key;
				break;

TEXT;
				}
				continue;
			}


			echo <<<TEXT
			case '$key': return \$this->instance->$key; break;

TEXT;
		}
		$this->closeSwitch();
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param \Sigmalab\SimpleReflection\IReflectedObject \$value
	 * @throws \Exception
	 */
	public function set_as_object(string \$name, \Sigmalab\SimpleReflection\IReflectedObject \$value):void
	{

TEXT;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $prop->name);
			$key = $prop->name;
			if ($prop->getType() && $prop->getType()->isBuiltin() || $decl == "mixed") continue;
			if ($isArray) {
				if ($this->isScalarType($decl)) {
					echo <<<TEXT
			case '$key': \$this->instance->$key  = [];
				foreach( \$value as \$arrayKey=>\$item ) {
					\$this->instance->{$key}[\$arrayKey] = ($decl)\$item;
				}
				break;

TEXT;
				}
				continue;
			}

			echo <<<TEXT
			case '$key': \$this->instance->{$key} = instance_cast(\$value, $decl::class); break;\n
TEXT;

		}
		$this->closeSwitch();
		$this->closeFunction();


		echo <<<TEXT

	/**
	 * @param string \$name
	 * @return \Sigmalab\SimpleReflection\IReflectedObject 
	 * @throws \Exception
	 */
	public function get_as_object(string \$name):?\Sigmalab\SimpleReflection\IReflectedObject 
	{

TEXT;
		$count = 0;
		ob_start();
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $prop->name);
			$key = $prop->name;
			if ($prop->getType() && $prop->getType()->isBuiltin()) continue;
			if ($isArray) continue;

			$count++;
			echo <<<TEXT
			case '$key': return \$this->instance->$key;\n
TEXT;
		}
		$this->closeSwitch();

		if (!$count) {
			ob_clean();
			echo "return null; /* exception will be prefer , but bug. */\n";
		} else {
			echo ob_get_clean();
		}
		$this->closeFunction();


		echo <<<TEXT

	/**
	 * @param string \$name
	 * @param \Sigmalab\SimpleReflection\IReflectedObject[] \$value
	 * @throws \Exception
	 */
	public function set_as_objects(string \$name, array \$value):void
	{

TEXT;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $prop->name);
			$key = $prop->name;
			if ($this->isScalarType($decl)) continue;
			if ($isArray) {
				if ($this->isScalarType($decl)) continue;

				echo <<<TEXT
			case '$key': 
				\$this->instance->$key  = [];
				foreach( \$value as \$arrayKey=>\$item ) {
					\$this->instance->{$key}[\$arrayKey] = instance_cast(\$item, $decl::class); ;
				}
				break;

TEXT;
			}
		}

		$this->closeSwitch();
		$this->closeFunction();

		echo <<<TEXT

	/**
	 * @param string \$name
	 * @return \Sigmalab\SimpleReflection\IReflectedObject[] 
	 * @throws \Exception
	 */
	public function get_as_objects(string \$name):array
	{

TEXT;
		$count = 0;
		ob_start();

		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $prop->name);
			$key = $prop->name;
			if ($this->isScalarType($decl)) continue;
			if ($isArray) {
				if ($this->isScalarType($decl)) continue;

				echo <<<TEXT
			case '$key':
				return \$this->instance->{$key}; 
//				\$this->instance->$key  = [];
//				foreach( \$value as \$arrayKey=>\$item ) {
//					\$this->instance->{$key}[\$arrayKey] = instance_cast(\$item, $decl::class); ;
//				}
//				break;

TEXT;
			}
		}

		$this->closeSwitch();
		if (!$count) {
			ob_clean();
			echo "return []; /* exception will be prefer , but bug. */\n";
		} else {
			echo ob_get_clean();
		}

		$this->closeFunction();


		$this->closeClass();
		return ob_get_clean();
	}


	/**
	 * @param $isArray
	 * @param $decl
	 * @return string
	 */
	private function getMixedTypeByDecl($isArray, $decl): string
	{
		if ($isArray) {
			switch ($decl) {
				case 'int':
				case 'integer':
				case 'string':
				case 'bool':
				case 'float':
				case 'mixed':
					return "\Sigmalab\SimpleReflection\ValueScalars";
					break;
				default:
					return "\Sigmalab\SimpleReflection\ValueObjects";
					break;
			}
		} else {
			switch ($decl) {
				case 'int':
				case 'integer':
				case 'string':
				case 'bool':
				case 'float':
				case 'mixed':
					return "\Sigmalab\SimpleReflection\ValueScalar";
					break;
				default:
					return "\Sigmalab\SimpleReflection\ValueObject";
					break;
			}
		}
	}

	/**
	 * @param $isArray
	 * @param $decl
	 * @return string
	 */
	private function getGetter($isArray, $decl): string
	{
		if ($isArray) {
			switch ($decl) {
				case 'int':
					return "get_as_int";
				case 'integer':
					return "get_as_int";
				case 'string':
					return "get_as_string";
				case 'bool':
					return "get_as_bool";
				case 'float':
					return "get_as_float";
				case 'mixed':
					return "get_as_mixed";
				default:
					return "get_as_array";
			}
		} else {
			switch ($decl) {
				case 'int':
					return "get_as_int";
				case 'integer':
					return "get_as_int";
				case 'string':
					return "get_as_string";
				case 'bool':
					return "get_as_bool";
				case 'float':
					return "get_as_float";
				case 'mixed':
					return "get_as_mixed";
				default:
					return "get_as_object";
			}
		}
	}

	private function outSetCase(string $key)
	{
		echo <<<TEXT
			case '$key': \$this->instance->$key  = \$value; break;

TEXT;
	}

	private function outGetCase(string $key)
	{
		echo <<<TEXT
			case '$key': return \$this->instance->$key;

TEXT;
	}

	private function closeSwitch()
	{
		echo <<<TEXT
			default: throw new \Exception("invalid argument: \$name");
		}

TEXT;
	}

	private function openSwitch()
	{
		echo <<<TEXT
		switch (\$name) {

TEXT;
	}

	/**
	 * @param $object
	 * @param string $targetType
	 * @throws \ReflectionException
	 */
	private function generateDirectSetSwitch($object, string $targetType): void
	{
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			$type = gettype($prop->getValue($object));
			$key = $prop->name;

			if ($type !== $targetType) continue;
			$this->outSetCase($key);
		}
		$this->closeSwitch();
	}

	/**
	 * @param $object
	 * @param string $targetType
	 * @throws \ReflectionException
	 */
	private function generateDirectGetSwitch($object, string $targetType): int
	{
		$count = 0;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			$type = gettype($prop->getValue($object));
			$key = $prop->name;

			if ($type !== $targetType) continue;
			$count++;
			$this->outGetCase($key);
		}
		$this->closeSwitch();
		return $count;
	}

	/**
	 * @param $decl
	 * @return bool
	 */
	private function isScalarType($decl): bool
	{
		return in_array($decl, ["string", "bool", "boolean", "float", "double", "int", "integer", "mixed"]);
	}

	private function closeClass(): void
	{
//close class;
		echo <<<TEXT
}

TEXT;
	}

	private function closeFunction(): void
	{
		echo <<<TEXT
	}

TEXT;
	}
}

#endif