
История чата от Автора (Алексей Васильев) от "а что будет если так сделать" до "работает и готово к применению".


---
7/10

Всем привет!

В KPHP нет рефлекшена, но для тех кому очень надо, то есть! 

Я накидал прототипчик: 

https://github.com/comm644/kphp_experiments/tree/main/testGetObjectVars

Просто, дешево сердито. Через генератор класса с метаданными, как в CxxTest/CxxMock. Не супер быстро, но для разбора строк в объект обычным циклом подойдет. (Например: при разборе Json в массив и потом установке в поля класса обобщенным способом)

В KPHP - реализация instance_to_array() красиво сделана, через такой же трюк (регистрация таблицы вызовов) можно обработчики set/get сделать для динамической установки/чтения свойств. Тогда рефлексия может быть чуть быстрее.

Я попробовал через таблицу функций сделать, чтобы адресация быстрее была вместо ветвлений, но callable в массиве не завелся %(

upd: подход подойдет для пакетного чтения json  
https://vkcom.github.io/kphp/kphp-language/howto-by-kphp/json-encode-decode.html

Но в целом такой подход годится для генератора десериализатора, тогда мы экономим на ветвлениях.



7/10

Q(Alex): каких других PHP-расширений вам не хватает в KPHP?


Если говорить о попытке упаковать всё приложение в KPHP сервер, то мы применяем:

xml, xsl - для  остатков шаблонов и парсинга внешних файлов
gd
mbstring 
curl  - для работы с внешними источниками или file_get_contents("http:/..." )

о БД:
sqlite  (via PDO)
postgres (via PDO)
memcache

Если делать адаптер  "App(KPHP) - Adapter (PHP) - Database" то боюсь на упаковке/распаковке  данных может ценность "скорость работы". Даже если сделать адаптер на чем-то компилируемом всё-равно потеряем на транзакционных издержках.



7/10

В документации не могу найти как вкомпилить свой код в результирующую сборку kphp (не залезая в код компилера)
Я думаю если это описать, то это даст возможность быстрого написания своих адаптеров за счёт применения #ifdef KPHP  и знания С++

я так понял что  через --extra-linker-flags   могу добавить библиотеку, но для неё нужны хедеры и сообщить kphp что такая функция есть. Ну или нужен какой-то трюк чтобы  загнать C++ вставку как есть. 

Я думаю что если это описать, то это может снизить нагрузку "Хочу ХХХХ сделайте" и упростит расширение сообществом. А то влезать во внутренности транспилера сильно сложнее чем настроить маршалинг (как в C# - Managed C++ - Native C++).

Для маршалинга нужно: 
1. Как делать  миграцию данных в kphp-объекты и обратно  ввиду управляемой памяти (хотя бы строки,массивы, скаляры).
2. Как вызвать свою функцию  (объявление для KPHP, линковка, использование типов kphp)  -


7/10

Q(Alex): скоро будет FFI


О, супер!  Значит можно уже ставить в план миграцию всего приложения в KPHP %)

Потому, как если через FFI сделать шлюз к pdo/memcache (а это уже понятная задача),  то решается проблема с базами данных и снимает препятствия по боевому применению.


7/10
Q(Alex):С базами данных сложнее, но думаю потом понятнее будет



Если FFI будет, то как нибудь прорвёмся. %)

Я кратко глянул внутрь pdo - он цепляет ядро php. Поэтому прямое включение модуля не прокатит.
Вариант c FFI и полифиллами наиболее жизнеспособен для быстрого старта в условиях "напрямую зацепить библиотеку" .



7/10

upd: подход подойдет для пакетного чтения json  
https://vkcom.github.io/kphp/kphp-language/howto-by-kphp/json-encode-decode.html

Но в целом такой подход годится для генератора десериализатора, тогда мы экономим на ветвлениях.

то есть:
$array  = json_decode($json, true);
$user = new User;
User_reader::fromArray($user, $array);

User_reader - автогенеренный код установки полей.



7/10

У удивлен что проектах PHP  как на самом мощном текстовом процессоре, не сильно много практикуется  кодогенерация. У меня в проекте  я много чего генерю: схемы БД, схемы для UI , сквозные типы для FlowJS и тд. 
Для KPHP пришлось адаптировать генератор классов чтобы попытаться запихнуть свои типы в msgpack




17/10
Q(Alex) : чего не хватает в KPHP?

php_zip  еще не хватает. (хотя его можно наверное  обойти с реализацией на чистом пыхе..)

upd: PhpZip не взлетает с полпинка.

upd2:  PhpArchive https://github.com/splitbrain/php-archive   после отрезания части функций и приведения нескольких сигнатур функций к жестким типам  собрался под KPHP и даже сделал zip архив.

Теперь меня мучает вопрос как сделать запускаемый CLI модуль на windows..




21/10


Я обновил эксперимент  c рефлекшеном до полноценного решения с json_decode   в свойства класса.

https://github.com/comm644/kphp_experiments/tree/main/testGetObjectVars

получилось вполне съедобно. 

в коде включаем генеренный трейт с таблицей маппинга. (паттерн Generation Gap)
class A
{
  use A_refection;
..

и начинает работать магия
 $object->setPropertyValue("name", 'other value');
 $object->setPropertyValue("value", 10);

и
 можно делать типовой импорт

$jsonArray = json_decode('{"name":"text", "value":10}', true );
foreach($jsonArray as $key  => $value ) {
        $object->setPropertyValue((string)$key, $value );
}

экспорт как обычно через instance_to_array() + json_encode($array);

и можно сделать относительно (шаблонизации то нет) типонезавимый reader/writer



22/10

@quasilyte я поймайл схему с кложурками


==
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Compilation error at stage: Preprocess function, gen by name-gen.cpp:165
  testHandlers.php:22
    

Invalid call ...->__invoke(): $handlers is not an array of instances or it can't be detected.
Add phpdoc to variable or @return tag to function was used to initialize it.


~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Compilation error at stage: Preprocess function, gen by preprocess-function.cpp:566
  testHandlers.php:22
    

Unknown function ->__invoke() of callable



22/10

Может есть какой-то обходной путь?

Таблица обработчиков вполне нормальное решение для реализации рефлекшена на кодогенерации. Но что-то сама таблица не поднимается.

рефлекшен нужен для всяких автоматических разборов, конечно он не быстрый из -за постоянных вызовов, но даёт быстрый старт. 

А Таблица функций - у меня вообще это основная шина связывания компонент.



22/10

не прокатило.

  Handler.php:31  in Handler::invoke
    return $handler();

Invalid call ...->__invoke(): $handler is not an instance or it can't be detected

Unknown function ->__invoke() of callable

любая попытка сохранить в чем-то обработчик кроме стековой переменной приводит к такому поведению.



22/10

>>Можно ещё кодогенерировать main со свитчем, где нужные обработчики вызываются.

Этот трюк я  обошёл  для полей класса. Но нужен реестр с заполнениеем в рантайме..

ps: хотя для рефлекшена генератор подойдет, а вот для шины обмена уже нет.



22/10

Оппаньки. мой косяк. не проверил доку.
да, этот подход работает.

а как кастануть   массив объектов  Class[]  в  абы-что массив? 

а то проверки типизатора прошел (return any), но компилер упал:

‘array<class_instance<C$B> >’ to ‘mixed’


если в терминах C++   то хочется сделать боксинг до VARIABLE_TYPE который принимает всё.

VARIABLE_TYPE  getPropertyByName( std::string name  )
{
   if ( name == "floatValue" ) return VARIABLE_TYPE( this->floatValue );
   if ( name == "intValue" ) return VARIABLE_TYPE( this->intValue );
   if ( name == "arrayB" ) return VARIABLE_TYPE( (void*)this->arrayB );
   if ( name == "valueB" ) return VARIABLE_TYPE( (void*)this->valueB );
    return null;
}



22/10

проверил схему.

Cо зверским кодгеном  и  интерфейсами завелся типизированный парсинг json в типизированные объекты. 

Для этого :
* вся структура объектов должна реализовывать интерфейс поддержки рефлекшена
* нужно явно регистрировать класс чтобы его можно было создать по имени . (статический конструктор бы..)
 
interface ICanReflection
{
 public function getPropertyType(string $name): TypeName;
 public function setPropertyValue(string $name, MixedValue $value) :void;
 public function getPropertyValue(string $name) : MixedValue;
}

от MixedValue наследуем варианты ObjectValue, ArrayValue, ScalarArrayValue, ScalarValue
в реализации  ICanReflection жуткий кодген ручным  копированием массива object[] в class[] через instance_cast<>

чуть позже выложу решение.

в общем, когда нельзя но очень хочется, то можно.



22/10
Q (Alex): А для чего такая рефлексия понадобилась?


Нафига мне всё это: 

У нас много работы (интеграции)  с внешними системами, у которых json в API , для них уже есть структура типов с перепаковкой из "хз что за json" в нормальные типы. через циклы:

$object = new Data
foreach ( $jsonArray => $key = >$Value )  $object->$key = $value;

в этом простом цикле есть и рантайм проверка типов и рефлексия. Но это самый простой способ перепаковки из входных данных.

Я хочу упаковать (закрыть)  всю эту работу внутрь собранного приложения для поставки "коробки".

Поэтому пришлось сделать то, что нормально прокатит для статической типизации неизвестной фигни.


23/10

Домучал я рефлекшен, получилась вполне рабочая схема. Если внедрить схему сразу на С++ стороне то  работать наверное будет быстрее, за счёт экономии на объектах обвязки.  Но в таком виде тоже неплохо.

по ссылке: https://github.com/comm644/kphp_experiments/tree/main/testGetObjectVars

1. Парсер json в типизированные объекты на основе рефлекшена
2. Рефлекшен  с генератором классов обвязки.

Не удалось:
1. целевые объекты нужно наследовать от общего пустого интерфейса (ICanJson), иначе какие-то непонятки с кастовкой типов получаются. падает на этапе компиляции если нет общей базы у классов.  не удалось быстро победить. (ошибка сборки в  smart_ptrs/intrusive_ptr.h )

2. непонял как шаблонизировать вызов в возвращаемый тип  (шаблонная функция) чтобы не делать кастовку в точке применения.
аналог такого:  
T method<T>(T prototype) {
 ... 
 return instance_cast(result, T::class);
}

23/10
@quasilyte @unserialize 

Коллеги, а как-то можно опции --Xkphp-options  (типа   --Xkphp-options --disable-sql )  в рантайме установить или вкомпилировать?  чтоб при вызове CLI  уже они не требовались?





23/10

Рефлекшен для KPHP - а теперь с малиновым вкусом. ()

накинул поддержку вызовом методов, причесал.
https://github.com/comm644/kphp_experiments/blob/main/testReflection/Readme.md

В общем production ready уже.

Сложности:
1. В выводом типов вообще шаманство получается.  Если базового типа нет, при построении боксинга для (object) появляется единственная версия которая несовместипа с другими типами и всё ломается в сборке  на 
error: use of deleted function
 потому что класс уже специализирован типом А , а  instance_cast<B> возвращает bool который нельзя кастануть.

то есть нехватает шаблонизации объектов, того самого  "@kphp-template-class".

тут есть рацуха:  
 @kphp-template $a $b   применимый к контруктору в минимуме дает шаблонизацию класса. 

2.  Все массивы пришлось вручную копировать при кастовке типов практических на всех анбоксингах при  установке значения и вызов метода. То есть вызовы весьма затратные. 

Если двинуть решение в рефлекшеном на уровень kphp  (в С++ почти тоже самое будет, но в некоторых местах можно сэкономить на вызовах.

3.   В Json  при кастовке mixed  в mixed[]  пришлось копировать массив. Хотя я точно знаю что по адресу лежит mixed[] (он же в цикле итерится), но не понял как сделать приведение типов. при объявлении впрямую ругается.

Есть ли трюк жестко привести тип mixed  в mixed[]  ?



23/10

вот в коде и параметризация  по общему знаменателю или по первому аргументу

struct C$ValueObject final : public C$ValueMixed {
  class_instance<C$
IReflectedObject
> $value{};
  const char *get_class() const  noexcept  final {
    return R"(ValueObject)";
  }
...
  };

то есть абстрактный object (как void*) не прокатывает.
public function __construct(object $value)

И если я делаю :
new ValueObject( new A )   - тут получим уже типзированный  
C$ValueObject
 с A
new ValueObject( new B)    - этот сломается. 

то есть без общего знаменателя всё падает в сборке.

Но есть же  в  нижнем базовом классе:
refcountable_polymorphic_php_classes

может абы-что object к нему привести?



23/10

К вопросу нафига мне рефлекшен.

Работать со статическими типами хорошо. Поэтому хорошо бы всякую неформализованную фигню загонять  в объекты.

Поэтому кроме парсинга json в объекты, рефлекшен активно применяется в ORM.
Для C# есть есть bltookit , он работает по атрибутам. у меня для PHP есть свой ORM который выгружает строку из БД в объект. через механику  $object>$key = $value

ORM не знает специфики объектов  поэтому есть два пути:

1.  генерация примеси  с реализацией интерфейса IHasSetterInt ,  IHasSetterString и тд чтобы вызывать нужный set_as_int(name, intval), set_as_string(name, stringValue)  чтобы принимать решение на основе типа колонки и вызывать нужный метод через кастовку к интерфейсу.  Тут мы всё равно будем иметь кастовку mixed в нужный тип, но за счёт знания типа колонки вполне решаемо. 

Минусы: еще один генератор
Плюсы: есть вероятность, что это может работать быстро.

2. использовать рефлекшен с "обобщенным путём". Тут рефлекшен не знает что за фигню мы пытаемся подсунуть, а  object и mixed несовместимы, то   придется дополнительно боксить в объекты уже самого рефлекшена а потом распаковывать.

Минусы: очень много упаковок и распаковок с созданием контейнерных объектов
Плюсы: уже работает.

Если  кого-то есть идея как сделать рефлекшен быстрее и проще чем у меня получилось welcome.  

Текущая реализация рефлекшена даёт возможность быстрой миграции всяких json и ORM, но работает не быстро.

история: в 2003 году я переписывал hotlog.ru с С++ на правильный С++, первые верcии его были на Perl, и кто-то раньше мигрировал его в С++ со всеми концепциями Перла (хеши вместо классов). Поэтому переписывание на иделогически верный C++ с ручным управлением типизированной памятью (как в играх) ускорило работу сервера со 100 до 3000 хитов в секунду по детальной статистике.
Поэтому память и количество вызовов на операцию имеют значение!

(интересно,  мои  рассуждалки полезны или шум? )


24/10

(картинка теста рефлекшена)

Ну теперь рефлекшен точно production ready. (адрес тот же)

Если мы знаем о типе значения - можно иметь дешёвый рефлекшен. Если не знаем, то очень дорого.  Массивы - всегда дорого. Объекты в массивах - очень дорого.

В mixed запихнуть можно что угодно, но достать быстро нельзя.

ps: и рефлекшен  это дорого
direct:       0.241
set_as_int:   5.120
set_as_mixed: 7.356
setPropertyValue: 17.571

на ветвлениях по строкам видимо теряется много.



25/10

Я проверил схему с шлюзом  к БД через  http (apache+ php-fpm) .  в виде:

клиент:  полностью формирует параметризованный SQL , пакует msgpack 
сервер: получает запрос , собирает в Pdo , результат пакует в msgpack
клиент: получает ответ 

в этом виде в KPHP режиме  время схемы сократилось 2 раза.  Схема вполне может быть рабочей. C прямым доступом не сравниваю, потери на сети всё равно.

пример шлюза опубликую. Если есть уровень изоляции запросов, то это может быть решением быстрым стартом в KPHP.

Подготовку SQL запросов и разбор в предметные объекты оставил на стороне клиента, он в машинном коде это сделает быстрее. 

итого есть решения для KPHP: 
+ рефлекшен 
+ распаковка json в объект (прямой кодген ридера будет еще быстрее работать)
+ схема проброса  запросов БД (пока тест)
+ относительно рабочий ORM совместимый с KPHP  

чего не хватает:
1. Шаблоны на основе типов чтобы T::class отрабатывал правильно для instance_cast()  

конечно
* @kphp-template T $wrapper
* @kphp-return   T::data

устанавливают что должна вернуть функция, но чтобы вернуть массив нужно в массив положить нечно соответствующее типу массив, а  instance_cast хочет четное определение типа. И игнорирует то что написано в тегах.

нафига: 
чтобы кастануть объекты сразу на входе в нужный тип массива через универсальную шаблонную функцию. а не плодить перепаковщиков с ветвлением по instanceof.




25/10

шаблоны:

/**
 * @param $proto
 * @return object
 * @kphp-template T $proto
 * @kphp-return T
 */
public function get(object $proto) : T
{
  return instance_cast($this->object, T::class);
}
$instanceA = $holder->get(new A);
$instanceB = $holder->get(new B)
;

ожидание:  создана функция по шаблону, если получаем шаблонный тип T , то все его использования должны подставиться на тип реализации шаблона

class_instance<C$A> f$Holder$$get$A(class_instance<C$Holder> const &v$this, class_instance<C$A> const &v$proto) noexcept  {
//62: {
//63: return instance_cast($this->object, T::class);
  return f$instance_cast< class_instance<C$A> >(v$this->$object, v$const_string$a_key);
}

по факту:
1 . результат не раскрылся
2.  подстановка для instance_cast
 
не раскрылась

//source = [testTemplate.php]
//61: public function get(object $proto) : T
class_instance<C$T> f$Holder$$get$A(class_instance<C$Holder> const &v$this, class_instance<C$A> const &v$proto) noexcept  {
//62: {
//63: return instance_cast($this->object, T::class);
  return f$instance_cast< class_instance<C$T> >(v$this->$object, v$const_string$usf7aa15be8a7d743e);
}


нафига: 
Если уж шаблонный класс сделать нельзя, то хочется кастовку по образцу.

/**
 * @param Holder $holder
 * @param object $class
 * @param $docs
 * @return array
 * @kphp-template T $class
 * @kphp-return   T[]
 */
function createArray(Holder $holder, $class): array
{
  $docs = [new T]; //try to create T[]
  for ($i = 0; $i < 10; ++$i) {
    $docs[] = instance_cast(clone $holder->object, T::class);
  }
  return $docs;
}

$arrayA =  createArray($holder, new A); // expect result A[]
$arrayB =  createArray($holder, new B); // expect result A[]


вопрос: это возможно реализовать?



25/10

Проверил скорость работы с БД (sqlite  прямая работа с файлом)

(выборка 200 записей, 100 циклов )

PHP  direct access: 1.70
PHP  via gate : 6.11
KPHP via gate:  2.04

то есть потери на шлюзе 20% 
можно ускорить за счёт перехода в c++ реализацию шлюза, но это писать надо.
или перейти в TL RPC схему чтобы исключить передачу апачем в fpm 
но мне не удалось её вкурить с двух попыток.

25/10

https://github.com/VKCOM/kphp/issues/345
добавил с примерами.



25/10

@quasilyte а когда cокеты в KPHP будут?

проблема:

KPHP - клиент ( БД которая  выставлена в "микросервис")
PHP - server ( имеет доступ к БД)

TL - не умеет быть сервером PHP  (см ниже)
HTTP - долго , хочется DGRAM  сокеты 

тайминг:
PHP  via socket : 4.45
то есть http  маршрутизация  стоит 20% времени если её убрать то схема "БД через шлюз" будет работать уже сейчас c приемлемой скоростью


TL:
/**
 * Deserializes a server RPC request to a corresponding typed TL class.
 * NB! Works only in KPHP - not in PHP - when it is launched as RPC server!
 * @return @tl\RpcFunction
 */
function rpc_server_fetch_request() {
  return null;
}


25/10

нашел stream_socket_*     (хотел socket* )
но не хватает stream_socket_sendto / stream_socket_recvfrom  для UDP

тайминг в режиме:
KPHP via direct http gate  (localhost):   1.63 
 
То есть доступ к БД через шлюз  вполне сравнился с прямым доступом из PHP.
Таким образом при большом пост-процессинге данных KPHP даст выигрыш по скорости. 

полные тейминги:
-=--
(выборка 200 записей, 100 циклов )

PHP  direct access: 1.70
PHP  via gate : 6.11 (apache + fpm)
PHP  via socket : 4.45 (script as server, UDG)
PHP  via socket : 4.41 (script as server, UDP)
PHP via direct socket:  time: 4.62 (script as server, HTTP)

KPHP via gate:  2.04 (apache+fpm)
KPHP via socket direct : 1.63   (script as server, HTTP)


25/10

Я вообще хотел unix DGRAM , но их бeз socket_* не поднять.
Потом сделал Stream - этот работает, но есть оверхед на HTTP заголовках, а вручную протокол отслеживать не улыбается. К тому же клиентская часть всегда бросает соединение.

Потом сделал UDP чтобы проще пакеты разбирать - но словил отсутствие методов.

в общем танцы с бубном. потому что TL схема не поднялась в PHP как сервер


26/10


Опубликовал тест RPC для базы данных.
https://github.com/comm644/kphp_experiments/tree/main/testRpc

Итого с KPHP работает:

1. Sigmalab\Database (aka Temis.SQL) подсистема генерации SQL запросов на основе структур объектов SQL выражения в коде. (это ORM с  реализацией концепции .NET Linq для PHP). Агрессивно использует рефлекшен для разбора результата выборки и контроля изменений. 

2. Sigmalab\DatabaseEngine - шлюз в Sqlite в минимальной редакции доказывающей возможность выполнения запросов

3. Sigmalab\Json  - парсер JSON в объекты. Агрессивно использует рефлекшен для установки полей и создания объектов

4. Sigmalab\SimpleReflection - реализация рефлекшена для компиляции в KPHP. Получилось весьма сносно.

5. Sigmalab\Transport - реализация транспортный уровень для шлюза к БД., несколько вариантов реализации: socket ,  stream_socket   в вариантах  Unix Dgram, UDP, TCP (HTTP) 

Чего не хватило:

1. socket_stream_* не умеет UDP в KPHP

2. socket* нету в KPHP

3. Шаблоны не умеют полную подстановку типов. (тест приложен, заявка в KPHP заведена)

Общий итог:

1. Схема с KPHP и шлюзом рабочая, скорость работы с БД на шлюзе сопоставима по скорости с прямым доступом в БД из PHP. Там где KHP выигрывает по построению запроса , он проигрывает на шлюзе к БД. При добавлении пост-обработки данных KPHP  будет обгонять.

2. Рефлекшен - это дорого. Ели есть схема данных то лучше сделать генератор читалки JSON для прямой установки полей. Почему дорого:  потому что есть ветвления по имени. И хотя KPHP оптимизирует их по хешу, но затраты на вычисление хеша никуда не деваются.

Куда дальше:
1. Дальше буду встраивать полученный результат в основное приложение и биться с типами  с которыми я расслабился пользуясь свойствами PHP.

2. Есть возможность ускорения рефлекшена за счет замены строк на Enum.  Если мы знаем имя свойства заранее, то мы можем создать Enum полей и тогда адресация в setProperty() будет быстрая без вычисления хешей. Но такое потребует переписывания генераторов описателей колонок  БД и порвёт всю совместимость с существующим кодом.

Заключение:

Технология миграции ключевых позиций отработана для верcии KPHP (Jul  6 2021) . Результаты на GitHub. Наверное это была последняя публикация. Примерно с такими же выкладками я описываю будущую архитектуру приложений и отчеты к задачам. Когда в момент описания "это невозможно" понимаешь что-то возможно.

Буду благодарен если в KPHP появятся те пункты про которые я указал в "не хватило", и лицензию бы поправить для полифиллов на LGPL. 
 
Game over (Round 2 passed)