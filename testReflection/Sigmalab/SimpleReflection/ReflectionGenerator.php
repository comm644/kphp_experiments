<?php
#ifndef KPHP
//PHP only. not for KPHP


namespace Sigmalab\SimpleReflection;

use ReflectionClass;
use ReflectionMethod;

class ReflectionGenerator
{


	/**
	 * @param object $object
	 * @param $propertyName
	 * @param $m
	 * @return array
	 * @throws \ReflectionException
	 */
	function getArrayItemClassName(object $object, string $propertyName): array
	{
		$ref = new \ReflectionClass(get_class($object));
		$prop = $ref->getProperty($propertyName);
		preg_match("/@var\s+([A-Za-z_]+)(\[\])?/", $prop->getDocComment(), $m);
		$itemClassName = $m[1];
		if (count($m) == 3) {
			return array($itemClassName, true);
		}
		return array($itemClassName, false);
	}

	function getMixedType(object $object, string $propertyName)
	{
		list($decl, $isArray) = $this->getArrayItemClassName($object, $propertyName);

		return $this->getMixedTypeByDecl($isArray, $decl);
	}


	function generate(string $className)
	{
		$object = new $className;
		$className = get_class($object);

		ob_start();

		echo <<<TEXT
<?php

//autogenerated
class {$className}_reflection implements \Sigmalab\SimpleReflection\ICanReflection
{
	/** ${className} */
	private ${className} \$instance;
	
	public function __construct(${className} \$instance) 
	{
		\$this->instance = \$instance;
	}
TEXT;

		echo <<<TEXT
	
	/**
	 * @kphp-required
	 * @param string \$name
	 * @return \Sigmalab\SimpleReflection\TypeName
	 */
	public function getPropertyType(string \$name) : \Sigmalab\SimpleReflection\TypeName
	{
		//autogenerated map
		switch (\$name) {

TEXT;

		$declareType = [];
		$declareInit = [];
		foreach (get_object_vars($object) as $key => $value) {

			list($decl, $isArray) = $this->getArrayItemClassName($object, $key);

			if ($isArray) {
				switch ($decl) {
					case 'int':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intArray';
						break;
					case 'integer':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intArray';
						break;
					case 'string':
						$code = '\Sigmalab\SimpleReflection\TypeName::$stringArray';
						break;
					case 'bool':
						$code = '\Sigmalab\SimpleReflection\TypeName::$boolArray';
						break;
					case 'float':
						$code = '\Sigmalab\SimpleReflection\TypeName::$floatArray';
						break;
					default:
						$declareType[] = "private static \Sigmalab\SimpleReflection\TypeName \${$key}_type;";
						$declareInit[] = "self::\${$key}_type = new \Sigmalab\SimpleReflection\TypeName('$decl', \Sigmalab\SimpleReflection\TypeName::Array );";
						$code = "self::\${$key}_type";
						break;
				}
			} else {
				switch ($decl) {
					case 'int':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intValue';
						break;
					case 'integer':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intValue';
						break;
					case 'string':
						$code = '\Sigmalab\SimpleReflection\TypeName::$stringValue';
						break;
					case 'bool':
						$code = '\Sigmalab\SimpleReflection\TypeName::$boolValue';
						break;
					case 'float':
						$code = '\Sigmalab\SimpleReflection\TypeName::$floatValue';
						break;
					default:
						$declareType[] = "private static \Sigmalab\SimpleReflection\TypeName \${$key}_type;";
						$declareInit[] = "self::\${$key}_type = new \Sigmalab\SimpleReflection\TypeName('$decl', \Sigmalab\SimpleReflection\TypeName::Object );";
						$code = "self::\${$key}_type";
						break;
				}
			}
			echo <<<TEXT
			case '$key': return $code;

TEXT;
		}
		echo <<<TEXT
		}             
		return \Sigmalab\SimpleReflection\TypeName::\$intValue;
	}
	

	/**
	 * @kphp-required
	 * @param string \$name
	 * @param \Sigmalab\SimpleReflection\ValueMixed \$value
	 */
	public function setPropertyValue(string \$name, \Sigmalab\SimpleReflection\ValueMixed \$value) : void
	{
		//autogenerated map
		switch (\$name) {

TEXT;

		$ref = new ReflectionClass($object);

		foreach (get_object_vars($object) as $key => $value) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $key);

			$prop = $ref->getProperty($key);
			$isNullable = $prop->getType()->allowsNull();

			echo "/* $decl */\n";
			$type = gettype($value);
			if ($type === "integer") $type = "int";

			echo <<<TEXT
		case '$key':

TEXT;

			$getter = self::getGetter($isArray, $decl);
			if ($isArray) {
				switch ($decl) {
					case 'int':
					case 'integer':
					case 'string':
					case 'bool':
					case 'float':
						echo <<<TEXT
				if (\$value instanceof \Sigmalab\SimpleReflection\ValueScalars) {
					\$this->instance->$key  = \$value->$getter();
				}

TEXT;
						break;
					default:
						echo <<<TEXT
				\$this->instance->$key = [];
				if (\$value instanceof \Sigmalab\SimpleReflection\ValueObjects) {
					foreach (\$value->getValue() as \$arrayValue) {
						\$this->instance->{$key}[] =  instance_cast(\$arrayValue, $decl::class);
					}
				}

TEXT;
						break;
				}
			} else {
				switch ($decl) {
					case 'int':
					case 'integer':
					case 'string':
					case 'bool':
					case 'float':
						echo <<<TEXT
			if (\$value instanceof \Sigmalab\SimpleReflection\ValueScalar) {
				\$this->instance->$key = \$value->$getter();
			}


TEXT;
						break;

					default:
						echo <<<TEXT
			if ( \$value instanceof \Sigmalab\SimpleReflection\ValueObject ) {
				\$this->instance->$key = instance_cast(\$value->getValue(), $decl::class); 
			}

TEXT;
						break;
				}
			}
			echo <<<TEXT
			break;

TEXT;
		}
		echo <<<TEXT
		}
	}

	/**
	 * @kphp-required
	 * @param string \$name
	 * @return \Sigmalab\SimpleReflection\ValueMixed
	 */
	public function getPropertyValue(string \$name) :\Sigmalab\SimpleReflection\ValueMixed
	{
		//autogenerated map
		switch (\$name) {

TEXT;

		foreach (get_object_vars($object) as $key => $value) {
			$mixedType = $this->getMixedType($object, $key);
			echo <<<TEXT
			case '$key': return new $mixedType( \$this->instance->$key );

TEXT;
		}

		echo <<<TEXT
		}
		return null;
	}
	
TEXT;

		$declaredTypes = implode("\n	", $declareType);
		$declaredInit = implode("\n		", $declareInit);
		echo <<<TEXT

	public static function registerClass()
	{   
		\Sigmalab\SimpleReflection\ClassRegistry::registerClass('{$className}', function(){ return new $className; });
		\Sigmalab\SimpleReflection\ClassRegistry::registerReflection('{$className}_reflection', function(object \$instance){ 
			return new {$className}_reflection(instance_cast(\$instance, ${className}::class)); 
		});
		{$declaredInit}
	}
	{$declaredTypes}

TEXT;

		$ref = new ReflectionClass($object);
		$methods = $ref->getMethods(ReflectionMethod::IS_PUBLIC);

		echo <<<TEXT
	/**
	 * @param string \$methodName
	 * @param \Sigmalab\SimpleReflection\ValueMixed[] \$args
	 */
	public function callMethod(string \$methodName, array \$args) :void
	{
		switch (\$methodName)
		{

TEXT;


		foreach ($methods as $method) {
			if ($method->name == "__construct") continue;
			echo <<<TEXT
			case '{$method->name}':
				\$this->invoke_{$method->name}(\$args);
				break;

TEXT;

		}

		echo <<<TEXT
		}
	}

TEXT;
		foreach ($methods as $method) {
			if ($method->name == "__construct") continue;
			echo <<<TEXT
	/**
	 * @param \Sigmalab\SimpleReflection\ValueMixed[] \$args
	 */
	private function invoke_{$method->name}(array \$args)
	{

TEXT;


			$paramTypes = [];
			preg_match_all('/@param\s+([A-Za-z_]+)\s*(\[\])?\s+\$([A-Za-z0-9_]+)/', $method->getDocComment(), $m);
			foreach ($m[3] as $idx => $paramName) {
				$paramTypes[$paramName] = (object)["name" => $paramName, "type" => $m[1][$idx], "isArray" => $m[2][$idx] == "[]"];
			}

			$args = [];
			foreach ($method->getParameters() as $idx => $param) {
				$type = $param->getType();
				$castType = $type->isBuiltin() ? $type : "object";

				$args[] = "\$arg{$idx}";
				$valueType = $this->getMixedTypeByDecl($param->isArray(), $paramTypes[$param->name]->type);
				$getter = $this->getGetter($param->isArray(), $paramTypes[$param->name]->type);
				$objectType = $paramTypes[$param->name]->type;
				if ($type->isBuiltin()) {
					echo <<<TEXT

		\$value{$idx} = \$args[{$idx}];
		if ( \$value{$idx} instanceof $valueType) {
			\$arg{$idx} = \$value{$idx}->$getter();
		}
		else {
			throw new Exception("Invalid argument {$idx}");
		}

TEXT;
					continue;
				}


				echo <<<TEXT

		\$value{$idx} = \$args[{$idx}];
		if ( \$value{$idx} instanceof $valueType) {
			\$arg{$idx} = instance_cast(\$value{$idx}, $objectType::class);
		}
		else {
			throw new Exception("Invalid argument {$idx}");
		}

TEXT;
			}
			$arglist = implode(",", $args);
			echo <<<TEXT
		\$this->instance->{$method->name}($arglist);
TEXT;
			$this->closeFunction();
		}

		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param string \$value
	 * @throws Exception
	 */
	public function set_as_string(string  \$name, string \$value):void
	{

TEXT;
		$this->generateDirectSetSwitch($object, 'string');
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param int \$value
	 * @throws Exception
	 */
	public function set_as_int(string  \$name, int \$value):void
	{

TEXT;
		$this->generateDirectSetSwitch($object, 'integer');
		$this->closeFunction();

		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param float \$value
	 * @throws Exception
	 */
	public function set_as_float(string  \$name, float \$value):void
	{

TEXT;
		$this->generateDirectSetSwitch($object, 'double');
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param bool \$value
	 * @throws Exception
	 */
	public function set_as_bool(string  \$name, bool \$value):void
	{

TEXT;
		$this->generateDirectSetSwitch($object, 'boolean');
		$this->closeFunction();

		echo <<<TEXT
	/**
	 * @param string \$name
	 * @throws Exception
	 */
	public function set_as_null(string  \$name):void
	{

TEXT;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			$type = gettype($prop->getValue($object));
			$key = $prop->name;
			if (!$prop->getType()->allowsNull()) continue;
			echo <<<TEXT
			case '$key': \$this->instance->$key  = null; break;

TEXT;
		}
		$this->closeSwitch();
		$this->closeFunction();

		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param mixed \$value
	 * @throws Exception
	 */
	public function set_as_mixed(string \$name, \$value):void
	{

TEXT;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $prop->name);
			$key = $prop->name;
			if (!$prop->getType()->isBuiltin()) continue;
			if ($isArray) {
				if ($this->isScalarType($decl)) {
					echo <<<TEXT
			case '$key': \$this->instance->$key  = [];
				foreach( \$value as \$arrayKey=>\$item ) {
					\$this->instance->{$key}[\$arrayKey] = ($decl)\$item;
				}
				break;

TEXT;
				}
				continue;
			}


			echo <<<TEXT
			case '$key': \$this->instance->$key  = ($decl)\$value; break;

TEXT;
		}
		$this->closeSwitch();
		$this->closeFunction();

		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param \Sigmalab\SimpleReflection\IReflectedObject \$value
	 * @throws Exception
	 */
	public function set_as_object(string \$name, \Sigmalab\SimpleReflection\IReflectedObject \$value):void
	{

TEXT;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $prop->name);
			$key = $prop->name;
			if ($prop->getType()->isBuiltin()) continue;
			if ($isArray) {
				if ($this->isScalarType($decl)) {
					echo <<<TEXT
			case '$key': \$this->instance->$key  = [];
				foreach( \$value as \$arrayKey=>\$item ) {
					\$this->instance->{$key}[\$arrayKey] = ($decl)\$item;
				}
				break;

TEXT;
				}
				continue;
			}


			echo <<<TEXT

			case '$key': \$this->instance->$key = instance_cast(\$value, $decl::class); break;			 

TEXT;
		}
		$this->closeSwitch();
		$this->closeFunction();


		echo <<<TEXT
	/**
	 * @param string \$name
	 * @param \Sigmalab\SimpleReflection\IReflectedObject[] \$value
	 * @throws Exception
	 */
	public function set_as_objects(string \$name, array \$value):void
	{

TEXT;
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $prop->name);
			$key = $prop->name;
			if ($this->isScalarType($decl)) continue;
			if ($isArray) {
				if ($this->isScalarType($decl)) continue;

				echo <<<TEXT
			case '$key': 
				\$this->instance->$key  = [];
				foreach( \$value as \$arrayKey=>\$item ) {
					\$this->instance->{$key}[\$arrayKey] = instance_cast(\$item, $decl::class); ;
				}
				break;

TEXT;
			}
		}

		$this->closeSwitch();
		$this->closeFunction();


		$this->closeClass();
		return ob_get_clean();
	}


	/**
	 * @param $isArray
	 * @param $decl
	 * @return string
	 */
	private function getMixedTypeByDecl($isArray, $decl): string
	{
		if ($isArray) {
			switch ($decl) {
				case 'int':
				case 'integer':
				case 'string':
				case 'bool':
				case 'float':
					return "\Sigmalab\SimpleReflection\ValueScalars";
					break;
				default:
					return "\Sigmalab\SimpleReflection\ValueObjects";
					break;
			}
		} else {
			switch ($decl) {
				case 'int':
				case 'integer':
				case 'string':
				case 'bool':
				case 'float':
					return "\Sigmalab\SimpleReflection\ValueScalar";
					break;
				default:
					return "\Sigmalab\SimpleReflection\ValueObject";
					break;
			}
		}
	}

	/**
	 * @param $isArray
	 * @param $decl
	 * @return string
	 */
	private function getGetter($isArray, $decl): string
	{
		if ($isArray) {
			switch ($decl) {
				case 'int':
					return "get_as_int";
				case 'integer':
					return "get_as_int";
				case 'string':
					return "get_as_string";
				case 'bool':
					return "get_as_bool";
				case 'float':
					return "get_as_float";
				default:
					return "get_as_array";
			}
		} else {
			switch ($decl) {
				case 'int':
					return "get_as_int";
				case 'integer':
					return "get_as_int";
				case 'string':
					return "get_as_string";
				case 'bool':
					return "get_as_bool";
				case 'float':
					return "get_as_float";
				default:
					return "get_as_object";
			}
		}
	}

	private function getCase(string $key)
	{
		echo <<<TEXT
			case '$key': \$this->instance->$key  = \$value; break;

TEXT;
	}

	private function closeSwitch()
	{
		echo <<<TEXT
			default: throw new Exception("invalid argument");
		}

TEXT;
	}

	private function openSwitch()
	{
		echo <<<TEXT
		switch (\$name) {

TEXT;
	}

	/**
	 * @param $object
	 * @param string $targetType
	 * @throws \ReflectionException
	 */
	private function generateDirectSetSwitch($object, string $targetType): void
	{
		$this->openSwitch();
		$ref = new ReflectionClass($object);
		foreach ($ref->getProperties(\ReflectionProperty::IS_PUBLIC) as $prop) {
			$type = gettype($prop->getValue($object));
			$key = $prop->name;

			if ($type !== $targetType) continue;
			$this->getCase($key);
		}
		$this->closeSwitch();
	}

	/**
	 * @param $decl
	 * @return bool
	 */
	private function isScalarType($decl): bool
	{
		return in_array($decl, ["string", "bool", "boolean", "float", "double", "int", "integer"]);
	}

	private function closeClass(): void
	{
//close class;
		echo <<<TEXT
}

TEXT;
	}

	private function closeFunction(): void
	{
		echo <<<TEXT
	}

TEXT;
	}
}

#endif