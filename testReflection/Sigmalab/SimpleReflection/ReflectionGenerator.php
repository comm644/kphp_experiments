<?php
#ifndef KPHP
//PHP only. not for KPHP


namespace Sigmalab\SimpleReflection;

use ReflectionClass;
use ReflectionMethod;

class ReflectionGenerator
{


	/**
	 * @param object $object
	 * @param $propertyName
	 * @param $m
	 * @return array
	 * @throws \ReflectionException
	 */
	function getArrayItemClassName(object $object, string $propertyName): array
	{
		$ref = new \ReflectionClass(get_class($object));
		$prop = $ref->getProperty($propertyName);
		preg_match("/@var\s+([A-Za-z_]+)(\[\])?/", $prop->getDocComment(), $m);
		$itemClassName = $m[1];
		if (count($m) == 3) {
			return array($itemClassName, true);
		}
		return array($itemClassName, false);
	}

	function getMixedType(object $object, string $propertyName)
	{
		list($decl, $isArray) = $this->getArrayItemClassName($object, $propertyName);

		return $this->getMixedTypeByDecl($isArray, $decl);
	}


	function generate(string $className)
	{
		$object = new $className;
		$className = get_class($object);

		ob_start();

		echo <<<TEXT
<?php

//autogenerated
class {$className}_reflection implements \Sigmalab\SimpleReflection\ICanReflection
{
	/** ${className} */
	private ${className} \$instance;
	
	public function __construct(${className} \$instance) 
	{
		\$this->instance = \$instance;
	}
TEXT;

		echo <<<TEXT
	
	/**
	 * @kphp-required
	 * @param string \$name
	 * @return \Sigmalab\SimpleReflection\TypeName
	 */
	public function getPropertyType(string \$name) : \Sigmalab\SimpleReflection\TypeName
	{
		//autogenerated map
		switch (\$name) {

TEXT;

		$declareType = [];
		$declareInit = [];
		foreach (get_object_vars($object) as $key => $value) {

			list($decl, $isArray) = $this->getArrayItemClassName($object, $key);

			if ($isArray) {
				switch ($decl) {
					case 'int':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intArray';
						break;
					case 'integer':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intArray';
						break;
					case 'string':
						$code = '\Sigmalab\SimpleReflection\TypeName::$stringArray';
						break;
					case 'bool':
						$code = '\Sigmalab\SimpleReflection\TypeName::$boolArray';
						break;
					case 'float':
						$code = '\Sigmalab\SimpleReflection\TypeName::$floatArray';
						break;
					default:
						$declareType[] = "private static \Sigmalab\SimpleReflection\TypeName \${$key}_type;";
						$declareInit[] = "self::\${$key}_type = new \Sigmalab\SimpleReflection\TypeName('$decl', \Sigmalab\SimpleReflection\TypeName::Array );";
						$code = "self::\${$key}_type";
						break;
				}
			} else {
				switch ($decl) {
					case 'int':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intValue';
						break;
					case 'integer':
						$code = '\Sigmalab\SimpleReflection\TypeName::$intValue';
						break;
					case 'string':
						$code = '\Sigmalab\SimpleReflection\TypeName::$stringValue';
						break;
					case 'bool':
						$code = '\Sigmalab\SimpleReflection\TypeName::$boolValue';
						break;
					case 'float':
						$code = '\Sigmalab\SimpleReflection\TypeName::$floatValue';
						break;
					default:
						$declareType[] = "private static \Sigmalab\SimpleReflection\TypeName \${$key}_type;";
						$declareInit[] = "self::\${$key}_type = new \Sigmalab\SimpleReflection\TypeName('$decl', \Sigmalab\SimpleReflection\TypeName::Object );";
						$code = "self::\${$key}_type";
						break;
				}
			}
			echo <<<TEXT
			case '$key': return $code;

TEXT;
		}
		echo <<<TEXT
		}             
		return \Sigmalab\SimpleReflection\TypeName::\$intValue;
	}
	

	/**
	 * @kphp-required
	 * @param string \$name
	 * @param \Sigmalab\SimpleReflection\ValueMixed \$value
	 */
	public function setPropertyValue(string \$name, \Sigmalab\SimpleReflection\ValueMixed \$value) : void
	{
		//autogenerated map
		switch (\$name) {

TEXT;

		foreach (get_object_vars($object) as $key => $value) {
			list($decl, $isArray) = $this->getArrayItemClassName($object, $key);
			$type = gettype($value);
			if ($type === "integer") $type = "int";

			echo <<<TEXT
		case '$key':

TEXT;

			if ($isArray) {
				switch ($decl) {
					case 'int':
					case 'integer':
					case 'string':
					case 'bool':
					case 'float':
						$getter = self::getGetter($isArray, $decl);
						echo <<<TEXT
				if (\$value instanceof \Sigmalab\SimpleReflection\ValueScalars) {
					\$this->instance->$key  = \$value->$getter();
				}

TEXT;
						break;
					default:
						echo <<<TEXT
				\$this->instance->$key = [];
				if (\$value instanceof \Sigmalab\SimpleReflection\ValueObjects) {
					foreach (\$value->getValue() as \$arrayValue) {
						\$this->instance->{$key}[] =  instance_cast(\$arrayValue, $decl::class);
					}
				}

TEXT;
						break;
				}
			} else {
				switch ($decl) {
					case 'int':
					case 'integer':
					case 'string':
					case 'bool':
					case 'float':
						echo <<<TEXT
			if (\$value instanceof \Sigmalab\SimpleReflection\ValueScalar) {
				\$this->instance->$key = ($type)\$value->getValue();
			}


TEXT;
						break;

					default:
						echo <<<TEXT
			if ( \$value instanceof \Sigmalab\SimpleReflection\ValueObject ) {
				\$this->instance->$key = instance_cast(\$value->getValue(), $decl::class); 
			}

TEXT;
						break;
				}
			}
			echo <<<TEXT
			break;

TEXT;
		}
		echo <<<TEXT
		}
	}

	/**
	 * @kphp-required
	 * @param string \$name
	 * @return \Sigmalab\SimpleReflection\ValueMixed
	 */
	public function getPropertyValue(string \$name) :\Sigmalab\SimpleReflection\ValueMixed
	{
		//autogenerated map
		switch (\$name) {

TEXT;

		foreach (get_object_vars($object) as $key => $value) {
			$mixedType = $this->getMixedType($object, $key);
			echo <<<TEXT
			case '$key': return new $mixedType( \$this->instance->$key );

TEXT;
		}

		echo <<<TEXT
		}
		return null;
	}
	
TEXT;

		$declaredTypes = implode("\n	", $declareType);
		$declaredInit = implode("\n		", $declareInit);
		echo <<<TEXT

	public static function registerClass()
	{   
		\Sigmalab\SimpleReflection\ClassRegistry::registerClass('{$className}', function(){ return new $className; });
		\Sigmalab\SimpleReflection\ClassRegistry::registerReflection('{$className}_reflection', function(object \$instance){ 
			return new {$className}_reflection(instance_cast(\$instance, ${className}::class)); 
		});
		{$declaredInit}
	}
	{$declaredTypes}

TEXT;

		$ref = new ReflectionClass($object);
		$methods = $ref->getMethods(ReflectionMethod::IS_PUBLIC);

		echo <<<TEXT
	/**
	 * @param string \$methodName
	 * @param \Sigmalab\SimpleReflection\ValueMixed[] \$args
	 */
	public function callMethod(string \$methodName, array \$args) :void
	{
		switch (\$methodName)
		{

TEXT;


		foreach ($methods as $method) {
			if ($method->name == "__construct") continue;
			echo <<<TEXT
			case '{$method->name}':
				\$this->invoke_{$method->name}(\$args);
				break;

TEXT;

		}

		echo <<<TEXT
		}
	}

TEXT;
		foreach ($methods as $method) {
			if ($method->name == "__construct") continue;
			echo <<<TEXT
	/**
	 * @param \Sigmalab\SimpleReflection\ValueMixed[] \$args
	 */
	private function invoke_{$method->name}(array \$args)
	{

TEXT;


			$paramTypes = [];
			preg_match_all('/@param\s+([A-Za-z_]+)\s*(\[\])?\s+\$([A-Za-z0-9_]+)/', $method->getDocComment(), $m);
			foreach ($m[3] as $idx=>$paramName) {
				$paramTypes[$paramName] = (object)["name"=>$paramName, "type"=>$m[1][$idx], "isArray"=>$m[2][$idx]=="[]" ];
			}

			$args = [];
			foreach ($method->getParameters() as $idx => $param) {
				$type = $param->getType();
				$castType = $type->isBuiltin() ? $type : "object";

				$args[] = "\$arg{$idx}";
				$valueType = $this->getMixedTypeByDecl($param->isArray(), $paramTypes[$param->name]->type);
				$getter = $this->getGetter($param->isArray(), $paramTypes[$param->name]->type);
				$objectType = $paramTypes[$param->name]->type;
				if ($type->isBuiltin()) {
					echo <<<TEXT

		\$value{$idx} = \$args[{$idx}];
		if ( \$value{$idx} instanceof $valueType) {
			\$arg{$idx} = \$value{$idx}->$getter();
		}
		else {
			throw new Exception("Invalid argument {$idx}");
		}

TEXT;
					continue;
				}


				echo <<<TEXT

		\$value{$idx} = \$args[{$idx}];
		if ( \$value{$idx} instanceof $valueType) {
			\$arg{$idx} = instance_cast(\$value{$idx}, $objectType::class);
		}
		else {
			throw new Exception("Invalid argument {$idx}");
		}

TEXT;
			}
			$arglist = implode(",", $args);
			echo <<<TEXT
		\$this->instance->{$method->name}($arglist);
	}

TEXT;

		}

		//close class;
		echo <<<TEXT
}

TEXT;


		return ob_get_clean();
	}

	/**
	 * @param $isArray
	 * @param $decl
	 * @return string
	 */
	private function getMixedTypeByDecl($isArray, $decl): string
	{
		if ($isArray) {
			switch ($decl) {
				case 'int':
				case 'integer':
				case 'string':
				case 'bool':
				case 'float':
					return "\Sigmalab\SimpleReflection\ValueScalars";
					break;
				default:
					return "\Sigmalab\SimpleReflection\ValueObjects";
					break;
			}
		} else {
			switch ($decl) {
				case 'int':
				case 'integer':
				case 'string':
				case 'bool':
				case 'float':
					return "\Sigmalab\SimpleReflection\ValueScalar";
					break;
				default:
					return "\Sigmalab\SimpleReflection\ValueObject";
					break;
			}
		}
	}
	/**
	 * @param $isArray
	 * @param $decl
	 * @return string
	 */
	private function getGetter($isArray, $decl): string
	{
		if ($isArray) {
			switch ($decl) {
				case 'int': return "get_as_int";
				case 'integer': return "get_as_int";
				case 'string': return "get_as_string";
				case 'bool': return "get_as_bool";
				case 'float': return "get_as_float";
				default: return "get_as_array";
			}
		} else {
			switch ($decl) {
				case 'int': return "get_as_int";
				case 'integer': return "get_as_int";
				case 'string': return "get_as_string";
				case 'bool': return "get_as_bool";
				case 'float': return "get_as_float";
				default: return "get_as_object";
			}
		}
	}
}

#endif